#BlueJ class context
comment0.params=
comment0.target=Force()
comment1.params=x\ y\ z
comment1.target=Force(double,\ double,\ double)
comment10.params=zValue
comment10.target=void\ setZComp(double)
comment11.params=xValue\ yValue
comment11.target=void\ addVector(double,\ double)
comment12.params=direction\ magnitude
comment12.target=void\ addVectorInDirection(int,\ double)
comment13.params=force
comment13.target=void\ addVector(Force)
comment14.params=xValue\ yValue
comment14.target=void\ subtractVector(double,\ double)
comment15.params=direction\ magnitude
comment15.target=void\ subtractVector(int,\ double)
comment16.params=force
comment16.target=void\ subtractVector(Force)
comment17.params=torque
comment17.target=void\ addTorque(double)
comment18.params=torque
comment18.target=void\ subtractTorque(double)
comment19.params=
comment19.target=java.lang.String\ toString()
comment2.params=
comment2.target=double\ getXComp()
comment20.params=actor
comment20.target=void\ move(BetterActor)
comment21.params=actor
comment21.target=void\ gravity(BetterActor)
comment21.text=public\ void\ move2(BetterActor\ actor)\ {\ //Applies\ movement\ to\ actors\ based\ on\ the\ x-component,\ y-component,\ and\ torque\n\ \ \ \ \ \ \ \ double\ x\ \=\ actor.getX()\ +\ xComp;\n\ \ \ \ \ \ \ \ double\ y\ \=\ actor.getY()\ +\ yComp;\n\ \ \ \ \ \ \ \ double\ z\ \=\ actor.getRotation()\ +\ zComp;\n\ \ \ \ \ \ \ \ actor.setLocation((int)x,\ (int)y);\ //The\ new\ position\ after\ movement\ is\ set\n\ \ \ \ \ \ \ \ actor.setRotation((int)z);\n\ \ \ \ \ \ \ \ lookForGround(actor);\n\ \ \ \ \ \ \ \ lookForWall2(actor);\n\ \ \ \ \ \ \ \ lookForCeiling2(actor);\n}
comment22.params=actor
comment22.target=void\ lookForWall(BetterActor)
comment22.text=public\ void\ lookForGround(BetterActor\ actor)\ {\ //Makes\ objects\ react\ to\ hitting\ the\ ground\n\ \ \ \ \ \ \ \ while\ (isTouchingGround2(actor))\ {\n\ \ \ \ \ \ \ \ \ \ \ \ actor.setLocation(actor.getX(),\ actor.getY()-1);\ \n\ \ \ \ \ \ \ \ }\n}
comment23.params=actor
comment23.target=void\ lookForCeiling(BetterActor)
comment23.text=public\ void\ lookForWall2(BetterActor\ actor)\ {\ //Looks\ for\ walls\ the\ object\ might\ be\ colliding\ with\ and\ prevents\ it\ from\ moving\ through\ them\n\ \ \ \ \ \ \ \ while\ (isTouchingLeftWall(actor))\ {\n\ \ \ \ \ \ \ \ \ \ \ \ actor.setLocation(actor.getX()+1,\ actor.getY());\n\ \ \ \ \ \ \ \ }\n\ \ \ \ \ \ \ \ while\ (isTouchingRightWall(actor))\ {\n\ \ \ \ \ \ \ \ \ \ \ \ actor.setLocation(actor.getX()-1,\ actor.getY());\n\ \ \ \ \ \ \ \ }\n}
comment24.params=actor
comment24.target=boolean\ isTouchingCeiling(BetterActor)
comment24.text=public\ void\ lookForCeiling2(BetterActor\ actor)\ {\n\ \ \ \ \ \ \ \ while\ (isTouchingCeiling2(actor))\ {\n\ \ \ \ \ \ \ \ \ \ \ \ actor.setLocation(actor.getX(),\ actor.getY()+1);\n\ \ \ \ \ \ \ \ \ \ \ \ setYComp(0);\n\ \ \ \ \ \ \ \ }\n}
comment25.params=actor
comment25.target=boolean\ isTouchingWall(BetterActor)
comment25.text=public\ boolean\ isTouchingCeiling2(BetterActor\ actor)\ {\ //Checks\ to\ see\ if\ touching\ ceiling\n\ \ \ \ \ \ \ \ boolean\ result\ \=\ false;\n\ \ \ \ \ \ \ \ double\ height\ \=\ (actor.getImage().getHeight()-actor.botExcess-actor.topExcess)/4\ -\ 1;\ //This\ represents\ a\ quarter\ of\ the\ image's\ actual\ height\n\ \ \ \ \ \ \ \ ArrayList\ ceilingPoints\ \=\ new\ ArrayList();\ //This\ is\ the\ array\ in\ which\ all\ points\ involved\ with\ detection\ of\ ceilings\ will\ be\ kept\n\ \ \ \ \ \ \ \ for\ (int\ i\=0;\ i<actor.detectPoints.size();\ i++)\ {\ //The\ loop\ checks\ through\ all\ the\ points\ defined\ in\ the\ object's\ detectPoints\ ArrayList\n\ \ \ \ \ \ \ \ \ \ \ \ if\ (actor.detectPoints.get(i).getY()<\=(-height))\ {\ //If\ a\ point\ is\ more\ than\ 3/4\ of\ the\ way\ up\ the\ image,\ it\ will\ be\ used\ to\ detect\ ceilings\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ceilingPoints.add(actor.betterGetOneObjectAtOffset(actor.detectPoints.get(i).getX(),\ actor.detectPoints.get(i).getY(),\ Platform.class));\n\ \ \ \ \ \ \ \ \ \ \ \ }\n\ \ \ \ \ \ \ \ }\n\ \ \ \ \ \ \ \ for\ (int\ i\=0;\ i<ceilingPoints.size();\ i++)\ {\ //Another\ loop\ then\ checks\ all\ of\ the\ points\ singled\ out\ for\ ceiling\ detection\n\ \ \ \ \ \ \ \ \ \ \ \ if\ (ceilingPoints.get(i)\!\=null)\ {\ //If\ there\ is\ a\ platform\ at\ any\ of\ those\ points,\ the\ methods\ returns\ true\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ result\ \=\ true;\n\ \ \ \ \ \ \ \ \ \ \ \ }\n\ \ \ \ \ \ \ \ }\n\ \ \ \ \ \ \ \ if\ (actor.getY()<\=(actor.getImage().getHeight()/2-actor.topExcess-1))\n\ \ \ \ \ \ \ \ \ \ \ \ result\ \=\ true;\n\ \ \ \ \ \ \ \ return\ result;\n}
comment26.params=actor
comment26.target=boolean\ isTouchingGround(BetterActor)
comment26.text=public\ boolean\ isTouchingLeftWall(BetterActor\ actor)\ {\ //Checks\ to\ see\ if\ touching\ a\ wall\ on\ the\ left\n\ \ \ \ \ \ \ \ boolean\ result\ \=\ false;\n\ \ \ \ \ \ \ \ double\ height\ \=\ (actor.getImage().getHeight()-actor.botExcess-actor.topExcess)/4\ -\ 1;\n\ \ \ \ \ \ \ \ double\ width\ \=\ actor.getImage().getHeight()/2\ -\ actor.leftExcess\ -\ 1;\n\ \ \ \ \ \ \ \ ArrayList\ leftWallPoints\ \=\ new\ ArrayList();\n\ \ \ \ \ \ \ \ for\ (int\ i\=0;\ i<actor.detectPoints.size();\ i++)\ {\n\ \ \ \ \ \ \ \ \ \ \ \ if\ (actor.detectPoints.get(i).getX()<\=0\ &&\ actor.detectPoints.get(i).getY()<\=height\ &&\ actor.detectPoints.get(i).getY()>\=-height)\ {\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ leftWallPoints.add(actor.betterGetOneObjectAtOffset(actor.detectPoints.get(i).getX(),\ actor.detectPoints.get(i).getY(),\ Platform.class));\n\ \ \ \ \ \ \ \ \ \ \ \ }\n\ \ \ \ \ \ \ \ }\n\ \ \ \ \ \ \ \ for\ (int\ i\=0;\ i<leftWallPoints.size();\ i++)\ {\n\ \ \ \ \ \ \ \ \ \ \ \ if\ (leftWallPoints.get(i)\!\=null)\ {\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ result\ \=\ true;\n\ \ \ \ \ \ \ \ \ \ \ \ }\n\ \ \ \ \ \ \ \ }\n\ \ \ \ \ \ \ \ if\ (actor.getX()<\=width)\n\ \ \ \ \ \ \ \ \ \ \ \ result\ \=\ true;\n\ \ \ \ \ \ \ \ return\ result;\n}
comment27.params=clss\ actor
comment27.target=boolean\ canSee(java.lang.Class,\ BetterActor)
comment27.text=public\ boolean\ isTouchingGround2(BetterActor\ actor)\ {\ //Checks\ to\ see\ if\ touching\ the\ ground\n\ \ \ \ \ \ \ \ boolean\ result\ \=\ false;\n\ \ \ \ \ \ \ \ double\ height\ \=\ (actor.getImage().getHeight()-actor.botExcess-actor.topExcess)/4\ -\ 1;\n\ \ \ \ \ \ \ \ ArrayList\ groundPoints\ \=\ new\ ArrayList();\n\ \ \ \ \ \ \ \ for\ (int\ i\=0;\ i<actor.detectPoints.size();\ i++)\ {\ \ \ //Implementation\ is\ similar\ to\ isTouchingCeiling2(),\ but\ looks\ for\n\ \ \ \ \ \ \ \ \ \ \ \ if\ (actor.detectPoints.get(i).getY()>height)\ {\ \ //points\ less\ than\ 1/4\ of\ the\ way\ up\ the\ image\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ groundPoints.add(actor.betterGetOneObjectAtOffset(actor.detectPoints.get(i).getX(),\ actor.detectPoints.get(i).getY(),\ Platform.class));\n\ \ \ \ \ \ \ \ \ \ \ \ }\n\ \ \ \ \ \ \ \ }\n\ \ \ \ \ \ \ \ for\ (int\ i\=0;\ i<groundPoints.size();\ i++)\ {\n\ \ \ \ \ \ \ \ \ \ \ \ if\ (groundPoints.get(i)\!\=null)\ {\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ result\ \=\ true;\n\ \ \ \ \ \ \ \ \ \ \ \ }\n\ \ \ \ \ \ \ \ }\n\ \ \ \ \ \ \ \ if\ (actor.getY()>\=actor.getWorld().getHeight()-(actor.getImage().getHeight()/2\ -\ actor.botExcess\ -\ 1))\n\ \ \ \ \ \ \ \ \ \ \ \ result\ \=\ true;\n\ \ \ \ \ \ \ \ return\ result;\n}
comment3.params=
comment3.target=double\ getYComp()
comment4.params=
comment4.target=double\ getZComp()
comment5.params=
comment5.target=double\ getDirectionOfForce()
comment6.params=
comment6.target=double\ getMagnitudeOfForce()
comment7.params=
comment7.target=double\ getDirectionOfTorque()
comment8.params=xValue
comment8.target=void\ setXComp(double)
comment9.params=yValue
comment9.target=void\ setYComp(double)
numComments=28
